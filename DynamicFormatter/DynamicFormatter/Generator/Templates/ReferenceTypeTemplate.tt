<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="DynamicFormatter.Extentions" #>
<#@ import namespace="DynamicFormatter.Extentions" #>
	public class <#= this.className #> :IResolver<<#=typeInfo.Type.FullName#>>
	{
	<#foreach(var field in this.typeInfo.Fields)
	  {
		if(this.isPrivate(field))
		{

			if(this.typeInfo.IsValueType)
			{#>
				Func<<#=typeInfo.Type.FullName#>, <#=this.FieldFullName(field)#>, <#=typeInfo.Type.FullName#>> Setter_<#=this.ValidateName(field)#>;

			<#}
			else
			{#>
				public Action<<#=typeInfo.Type.FullName#>, <#=this.FieldFullName(field)#>> Setter_<#=this.ValidateName(field)#>;

			<#}
		}
		
	 }#>
		
		TypeInfo typeInfo;

		public <#= this.className #>()
		{
			this.typeInfo = TypeInfo.instanse(typeof(<#=typeInfo.Type.FullName#>));

			<#foreach(var field in this.typeInfo.Fields)
			{
				if(this.isPrivate(field))
				{
							if(!this.typeInfo.IsValueType)
							{#>
								
								{
										ParameterExpression p1 = Expression.Parameter(typeof(<#=typeInfo.Type.FullName#>), "p1");
										ParameterExpression p2 = Expression.Parameter(typeof(<#=this.FieldFullName(field)#>), "p2");

										var m1 = Expression.MakeMemberAccess(p1, this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));
										BinaryExpression body = Expression.Assign(m1, p2);
										var lambda = Expression.Lambda<Action<<#=typeInfo.Type.FullName#>, <#=this.FieldFullName(field)#>>>(body, p1, p2);
										Setter_<#=this.ValidateName(field)#> = lambda.Compile();
								}

							<#}
							else
							{#>

							{
								ParameterExpression p1 = Expression.Parameter(typeof(<#=typeInfo.Type.FullName#>), "p1");
								ParameterExpression p2 = Expression.Parameter(typeof(<#=this.FieldFullName(field)#>), "p2");
								ParameterExpression SturctObjectParam = Expression.Variable(typeof(<#=typeInfo.Type.FullName#>), "Struct");
								ParameterExpression retObjectParam = Expression.Variable(typeof(<#=typeInfo.Type.FullName#>), "ret");

								LabelTarget returnTarget = Expression.Label(typeof(<#=typeInfo.Type.FullName#>));


								var assignToRet = Expression.Assign(SturctObjectParam, p1);
								var makeMeberAccess = Expression.MakeMemberAccess(SturctObjectParam, this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));

								var assign = Expression.Assign(makeMeberAccess, p2);
								var assingnToResult = Expression.Assign(
																retObjectParam,
																(SturctObjectParam));

								GotoExpression returnExpression = Expression.Return(returnTarget,
																				retObjectParam, typeof(<#=typeInfo.Type.FullName#>));

								LabelExpression returnLabel = Expression.Label(returnTarget, retObjectParam);

								BlockExpression block = Expression.Block(
																		new ParameterExpression[] { SturctObjectParam, retObjectParam },
																		assignToRet,
																		assign,
																		assingnToResult,
																		returnExpression,
																		returnLabel);
								var lambda = Expression.Lambda<Func<<#=typeInfo.Type.FullName#>, <#=this.FieldFullName(field)#>, <#=typeInfo.Type.FullName#>>>(block, p1, p2);
								Setter_<#=this.ValidateName(field)#> = lambda.Compile();
							}

							<#}
					}
			}
			#>

		}

		public object instanse(int offset, DynamicBuffer buff, Dictionary<int, object> referenceMaping)
		{
			byte[] buffer = buff.CurrentBuffer;

			short position = (short)offset == 0 ?
				 (short)0 : BaseConvertor.GetShort(buffer, offset);

			if (position == -1)
			{
				return null;
			}
			offset = position;

			var entity = (<#=typeInfo.Type.FullName#>)FormatterServices.GetSafeUninitializedObject(typeof(<#=typeInfo.Type.FullName#>));
			offset++;
			<#foreach(var field in this.typeInfo.Fields)
			{
				if(this.isPrimitive(field))
				{
					if(this.isPrivate(field))
					{#>
						<#if(this.typeInfo.IsValueType)
						{#>
							entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,BaseConvertor.Get<#=this.GetTypePrefix(field)#>(buffer, offset));
						<#}
						else
						{#>
							Setter_<#=this.ValidateName(field)#>.Invoke(entity,BaseConvertor.Get<#=this.GetTypePrefix(field)#>(buffer, offset));
						<#}
					}
					else
					{#>
							entity.<#=this.ValidateName(field)#> = BaseConvertor.Get<#=this.GetTypePrefix(field)#>(buffer, offset);
					<#}
					}
			  else if(field.FieldType == typeof(string))
			  {#>
				string <#=this.ValidateName(field)#> = DesirializeString(offset,buff,referenceMaping);
				<#if(this.isPrivate(field))
				{
					if(this.typeInfo.IsValueType)
					{#>
						entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>);
					<#}
					else
					{#>
						Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>);
					<#}
				}
				else
				{#>
					entity.<#=this.ValidateName(field)#>  = <#=this.ValidateName(field)#>;
				<#}
			 }
			 else
			 {#>
				
					<#=this.FieldFullName(field)#> <#=this.ValidateName(field)#>_Result =(<#=this.FieldFullName(field)#>) TypeResolveFactory.ResolveDesirialize(
																		typeof(<#=this.FieldFullName(field)#>),
																		offset,
																		buff,
																		referenceMaping);

				<#if(this.isPrivate(field))
				{#>

					<#if(this.typeInfo.IsValueType)
					{#>
							entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>_Result);
					<#}
					else
					{#>
							Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>_Result);
					<#}

				}
				else
				{#>
					entity.<#=this.ValidateName(field)#>  = <#=this.ValidateName(field)#>_Result;
				<#}

			 }#>
			  offset += <#=this.GetSizeInBuffer(field)#>;
			<#}#>

			<#if(this.typeInfo.IsValueType)
			{
				#>return (object)entity;<#
			}#>

			<#if(!this.typeInfo.IsValueType)
			{
				#>return entity;<#
			}#>
		}

		public unsafe string DesirializeString(int offset, DynamicBuffer buffer, Dictionary<int, object> referenceMaping)
		{
			fixed (byte* buf = buffer.CurrentBuffer)
			{
				short position = offset == 0 ? (short)0 : *(short*)(buf + offset);
				if (position == -1)
				{
					return null;
				}
				if (referenceMaping.ContainsKey(position))
				{
					return referenceMaping[position] as string;
				}
				int lenght = *(int*)(buf + position);

				fixed (char* charP = new char[lenght])
				{
					int bytesForCopy = sizeof(char) * lenght;
					byte* source = (buf + position + sizeof(int));
					Buffer.MemoryCopy(source, charP, bytesForCopy, bytesForCopy);
					return new String(charP);
				}
			}
		}
	}