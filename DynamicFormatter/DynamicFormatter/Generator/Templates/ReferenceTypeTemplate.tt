<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="DynamicFormatter.Extentions" #>
<#@ import namespace="DynamicFormatter.Extentions" #>
	public class <#= this.className #> :IResolver<<#=this.TypeName()#>>
	{
	<#foreach(var field in this.typeInfo.Fields)
	  {
		if(this.isPrivate(field) || this.isPrivate())
		{

			if(this.typeInfo.IsValueType)
			{#>
				Func<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>, <#=this.TypeName()#>> Setter_<#=this.ValidateName(field)#>;

			<#}
			else
			{#>
				public Action<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>> Setter_<#=this.ValidateName(field)#>;
			<#}#>

			public Func<<#=this.TypeName()#>,<#=this.FieldFullName(field)#>> Getter_<#=this.ValidateName(field)#>;

		<#}
		
	 }#>
		
		TypeInfo typeInfo;

		public <#= this.className #>()
		{
			<#if(!this.isPrivate())
			{#>
				this.typeInfo = TypeInfo.instanse(typeof(<#=this.TypeName()#>));
			<#}
			else
			{#>
				this.typeInfo = TypeInfo.instanse(<#=this.GetHash(this.typeInfo.Type)#>);
			<#}#>

			<#foreach(var field in this.typeInfo.Fields)
			{
				if(this.isPrivate())
				{#>
					{
											ParameterExpression p1 = Expression.Parameter(typeof(<#=this.TypeName()#>), "p1");
											Expression body = Expression.Field(Expression.Convert(p1, this.typeInfo.Type), this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));
											var lambda = Expression.Lambda<Func<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>>>(body, p1);
											Getter_<#=this.ValidateName(field)#> = lambda.Compile();
					}

					<#if(!this.typeInfo.IsValueType)
					{#>
										{
										ParameterExpression p1 = Expression.Parameter(typeof(<#=this.TypeName()#>), "p1");
										ParameterExpression p2 = Expression.Parameter(typeof(<#=this.FieldFullName(field)#>), "p2");

										var m1 = Expression.MakeMemberAccess(Expression.Convert(p1,this.typeInfo.Type), this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));
										Expression body = Expression.Assign(m1,Expression.Convert(p2,Typeinfo.instanse(<#=this.GetHash(field.FieldType)#>).Type));
										var lambda = Expression.Lambda<Action<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>>>(body, p1, p2);
										Setter_<#=this.ValidateName(field)#> = lambda.Compile();
										}
					<#}
					else
					{#>
										{
												ParameterExpression p1 = Expression.Parameter(typeof(<#=this.TypeName()#>), "p1");
												ParameterExpression p2 = Expression.Parameter(typeof(<#=this.FieldFullName(field)#>), "p2");
												ParameterExpression SturctObjectParam = Expression.Variable(this.typeInfo.Type, "Struct");
												ParameterExpression retObjectParam = Expression.Variable(typeof(<#=this.TypeName()#>), "ret");

												LabelTarget returnTarget = Expression.Label(typeof(<#=this.TypeName()#>));


												var assignToRet = Expression.Assign(SturctObjectParam, Expression.Convert(p1,this.typeInfo.Type));
												var makeMeberAccess = Expression.MakeMemberAccess(SturctObjectParam, this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));

												var assign = Expression.Assign(makeMeberAccess, p2);
												var assingnToResult = Expression.Assign(
																				retObjectParam,
																				 Expression.Convert(SturctObjectParam,typeof(object)));

												GotoExpression returnExpression = Expression.Return(returnTarget,
																								retObjectParam, typeof(<#=this.TypeName()#>));

												LabelExpression returnLabel = Expression.Label(returnTarget, retObjectParam);

												BlockExpression block = Expression.Block(
																						new ParameterExpression[] { SturctObjectParam, retObjectParam },
																						assignToRet,
																						assign,
																						assingnToResult,
																						returnExpression,
																						returnLabel);
												var lambda = Expression.Lambda<Func<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>, <#=this.TypeName()#>>>(block, p1, p2);
												Setter_<#=this.ValidateName(field)#> = lambda.Compile();
										}
					<#}#>
				<#}
				else if(this.isPrivate(field))
				{#>
							{
											ParameterExpression p1 = Expression.Parameter(typeof(<#=this.TypeName()#>), "p1");
											Expression body = Expression.Field(p1, this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));
											<#if(this.isPrivateClass(field.FieldType))
											{#>
											body = Expression.Convert(body,typeof(object));
											<#}#>
											var lambda = Expression.Lambda<Func<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>>>(body, p1);
											Getter_<#=this.ValidateName(field)#> = lambda.Compile();
							}
							<#if(!this.typeInfo.IsValueType)
							{#>
								
								{
										ParameterExpression p1 = Expression.Parameter(typeof(<#=this.TypeName()#>), "p1");
										ParameterExpression p2 = Expression.Parameter(typeof(<#=this.FieldFullName(field)#>), "p2");

										var m1 = Expression.MakeMemberAccess(p1, this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));
										<#if(this.isPrivateClass(field.FieldType))
										{#>
											BinaryExpression body = Expression.Assign(m1, Expression.Convert(p2,this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>).FieldType));
										<#}
										else
										{#>
											BinaryExpression body = Expression.Assign(m1, p2);
										<#}#>
										
										var lambda = Expression.Lambda<Action<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>>>(body, p1, p2);
										Setter_<#=this.ValidateName(field)#> = lambda.Compile();
								}

							<#}
							else
							{#>

							{
								ParameterExpression p1 = Expression.Parameter(typeof(<#=this.TypeName()#>), "p1");
								ParameterExpression p2 = Expression.Parameter(typeof(<#=this.FieldFullName(field)#>), "p2");
								ParameterExpression SturctObjectParam = Expression.Variable(typeof(<#=this.TypeName()#>), "Struct");
								ParameterExpression retObjectParam = Expression.Variable(typeof(<#=this.TypeName()#>), "ret");

								LabelTarget returnTarget = Expression.Label(typeof(<#=this.TypeName()#>));


								var assignToRet = Expression.Assign(SturctObjectParam, p1);
								var makeMeberAccess = Expression.MakeMemberAccess(SturctObjectParam, this.typeInfo.Fields.Single(x => RuntimeHelpers.GetHashCode(x) ==<#=this.GetHash(field)#>));

								var assign = Expression.Assign(makeMeberAccess, p2);
								var assingnToResult = Expression.Assign(
																retObjectParam,
																(SturctObjectParam));

								GotoExpression returnExpression = Expression.Return(returnTarget,
																				retObjectParam, typeof(<#=this.TypeName()#>));

								LabelExpression returnLabel = Expression.Label(returnTarget, retObjectParam);

								BlockExpression block = Expression.Block(
																		new ParameterExpression[] { SturctObjectParam, retObjectParam },
																		assignToRet,
																		assign,
																		assingnToResult,
																		returnExpression,
																		returnLabel);
								var lambda = Expression.Lambda<Func<<#=this.TypeName()#>, <#=this.FieldFullName(field)#>, <#=this.TypeName()#>>>(block, p1, p2);
								Setter_<#=this.ValidateName(field)#> = lambda.Compile();
							}

							<#}
					}
			}
			#>

		}


		public unsafe byte[] Serialize(object Entity, DynamicBuffer buff, Dictionary<object, DynamicBuffer.BufferPtr> referenceMaping)
		{
			if (Entity == null)
			{
				return BitConverter.GetBytes(((short)-1));
			}
			DynamicBuffer.BufferPtr ptr;
			if (referenceMaping.TryGetValue(Entity,out ptr))
			{
				return BitConverter.GetBytes(ptr.position);
			}
			ptr = buff.Alloc(<#=this.typeInfo.Size#>);
			short position = ptr.position;
			int offset = (int)position;
			byte[] buffer = buff.CurrentBuffer;

			<#=this.TypeName()#> entity = (<#=this.TypeName()#>)Entity;

			<#foreach(var field in this.typeInfo.Fields)
			{#>
				{
					<#=this.FieldFullName(field)#> value = <#

					if(this.isPrivate(field))
					{#>
						Getter_<#=this.ValidateName(field)#>(entity);
					<#}
					else
					{#>
						entity.<#=this.ValidateName(field)#>;
					<#}
					#>

					<#if(this.isPrimitive(field))
					{#>
						BaseConvertor.Write<#=this.SizeInBuffer(field) * 8#>(buffer,offset,(byte*)&value);
					<#}
					else
					{#>
						byte[] result = TypeResolveFactory.ResolveSerialize(<#=this.GetHash(field.FieldType)#>,value,buff,referenceMaping);
						System.Buffer.BlockCopy(result, 0, buffer, offset, result.Length);
					<#}#>

					offset += <#=this.SizeInBuffer(field)#>;

				}
			<#}#>

			return BitConverter.GetBytes(position);
		}


		public object instanse(int offset, DynamicBuffer buff, Dictionary<int, object> referenceMaping)
		{
			byte[] buffer = buff.CurrentBuffer;

			short position = (short)offset == 0 ?
				 (short)0 : BaseConvertor.GetShort(buffer, offset);

			if (position == -1)
			{
				return null;
			}
			if(referenceMaping.ContainsKey(position))
			{
				return referenceMaping[position];
			}
			offset = position;

			var entity = (<#=this.TypeName()#>)FormatterServices.GetSafeUninitializedObject(this.typeInfo.Type);
			referenceMaping.Add(position, entity);
			offset++;
			<#foreach(var field in this.typeInfo.Fields)
			{
				if(this.isPrimitive(field))
				{
					if(this.isPrivate(field))
					{#>
						<#if(this.typeInfo.IsValueType)
						{#>
							entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,BaseConvertor.Get<#=this.GetTypePrefix(field)#>(buffer, offset));
						<#}
						else
						{#>
							Setter_<#=this.ValidateName(field)#>.Invoke(entity,BaseConvertor.Get<#=this.GetTypePrefix(field)#>(buffer, offset));
						<#}
					}
					else
					{#>
							entity.<#=this.ValidateName(field)#> = BaseConvertor.Get<#=this.GetTypePrefix(field)#>(buffer, offset);
					<#}
					}
			  else if(field.FieldType == typeof(string))
			  {#>
				string <#=this.ValidateName(field)#> = DesirializeString(offset,buff,referenceMaping);
				<#if(this.isPrivate(field))
				{
					if(this.typeInfo.IsValueType)
					{#>
						entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>);
					<#}
					else
					{#>
						Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>);
					<#}
				}
				else
				{#>
					entity.<#=this.ValidateName(field)#>  = <#=this.ValidateName(field)#>;
				<#}
			 }
			 else if(this.isEnum(field))
			 {
				
					if(this.isPrivate(field))
					{
					if(this.typeInfo.IsValueType)
					{#>
						entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,(<#=field.FieldType.FullName#>)BaseConvertor.GetInt(buffer,offset));
					<#}
					else
					{#>
						Setter_<#=this.ValidateName(field)#>.Invoke(entity,(<#=field.FieldType.FullName#>)BaseConvertor.GetInt(buffer,offset));
					<#}
				}
				else
				{#>
					entity.<#=this.ValidateName(field)#>  =  (<#=field.FieldType.FullName#>)BaseConvertor.GetInt(buffer,offset);
				<#}	
				
			 }
			 else if(this.isNullable(field))
			 {#>
				{
				<#=this.FieldFullName(field)#> fieldValue = null;
					short ptrToNullable = BaseConvertor.GetShort(buffer, offset);
					bool hasValue = BaseConvertor.GetBool(buffer,ptrToNullable);
					if(hasValue)
					{
						<#var nullableTypeInfo = GetChildType(field);
						if(nullableTypeInfo.IsPrimitive || 
						nullableTypeInfo.Type == typeof(DateTime) || nullableTypeInfo.Type == typeof(Guid))
						{#>

						fieldValue = BaseConvertor.Get<#=this.GetTypePrefix(nullableTypeInfo.Type)#>(buffer,ptrToNullable +1);

						<#}
						else
						{#>


						fieldValue =  (<#=this.FieldFullName(field)#>)TypeResolveFactory.ResolveDesirialize(
																		<#=this.GetHash(field.FieldType)#>,
																		offset,
																		buff,
																		referenceMaping);
						<#}#>

						


					<#if(this.isPrivate(field))
					{
						if(this.typeInfo.IsValueType)
						{#>
							entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,fieldValue);
						<#}
						else
						{#>
							Setter_<#=this.ValidateName(field)#>.Invoke(entity,fieldValue);
						<#}
					}
					else
					{#>
							entity.<#=this.ValidateName(field)#> = fieldValue;
					<#}#>
					
					}
				}

			 <#}
			 else
			 {#>
				
					<#=this.FieldFullName(field)#> <#=this.ValidateName(field)#>_Result =(<#=this.FieldFullName(field)#>) TypeResolveFactory.ResolveDesirialize(
																		<#=this.GetHash(field.FieldType)#>,
																		offset,
																		buff,
																		referenceMaping);

				<#if(this.isPrivate(field))
				{#>

					<#if(this.typeInfo.IsValueType)
					{#>
							entity = Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>_Result);
					<#}
					else
					{#>
							Setter_<#=this.ValidateName(field)#>.Invoke(entity,<#=this.ValidateName(field)#>_Result);
					<#}

				}
				else
				{#>
					entity.<#=this.ValidateName(field)#>  = <#=this.ValidateName(field)#>_Result;
				<#}

			 }#>
			  offset += <#=this.GetSizeInBuffer(field)#>;
			<#}#>

			<#if(this.typeInfo.IsValueType)
			{
				#>
				return (object)entity;
				<#
			}#>



			<#if(!this.typeInfo.IsValueType)
			{
				#>return entity;<#
			}#>
		}

		public unsafe string DesirializeString(int offset, DynamicBuffer buffer, Dictionary<int, object> referenceMaping)
		{
			fixed (byte* buf = buffer.CurrentBuffer)
			{
				short position = offset == 0 ? (short)0 : *(short*)(buf + offset);
				if (position == -1)
				{
					return null;
				}
				if (referenceMaping.ContainsKey(position))
				{
					return referenceMaping[position] as string;
				}
				int lenght = *(int*)(buf + position);

				fixed (char* charP = new char[lenght])
				{
					int bytesForCopy = sizeof(char) * lenght;
					byte* source = (buf + position + sizeof(int));
					Buffer.MemoryCopy(source, charP, bytesForCopy, bytesForCopy);
					return new String(charP);
				}
			}
		}
	}