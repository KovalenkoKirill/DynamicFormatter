<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="DynamicFormatter.Extentions" #>
<#@ import namespace="DynamicFormatter.Extentions" #>

	public class <#= this.className #> :IResolver<<#=typeInfo.Type.FullName#>>
	{
		public object instanse(int offset, DynamicBuffer buff, Dictionary<int, object> referenceMaping)
		{
			byte[] buffer = buff.CurrentBuffer;

			short position = (short)offset == 0 ?
				 (short)0 : BaseConvertor.GetShort(buffer, offset);

			if (position == -1)
			{
				return null;
			}
			offset = position;

			int arrayLenght = BaseConvertor.GetInt(buffer, offset);

			<#=elementInfo.Type.FullName#>[] array = new <#=elementInfo.Type.FullName#>[arrayLenght];

			referenceMaping.Add(position, array);

			offset += <#=sizeof(int)#>;

			for(int i = 0;i<arrayLenght;i++)
			{
				<#if(this.isPrimitive())
				{#>
					array[i] = BaseConvertor.Get<#=this.Prefix#>(buffer, offset);
					offset += <#=this.elementInfo.SizeInBuffer#>;
				<#}
				else if(this.elementInfo.Type == typeof(string))
				{#>
					array[i] = DesirializeString(offset,buff,referenceMaping);
					offset += <#=sizeof(ushort)#>;
				<#}
				else
				{#>
					array[i] = (<#=elementInfo.Type.FullName#>)TypeResolveFactory.ResolveDesirialize(typeof(<#=elementInfo.Type.FullName#>),
																		offset,
																		buff,
																		referenceMaping);
					offset += <#=this.elementInfo.SizeInBuffer#>;
				<#}#>
			}
			return array;
		}

		<#if(this.elementInfo.Type == typeof(string))
		{#>
		public unsafe string DesirializeString(int offset, DynamicBuffer buffer, Dictionary<int, object> referenceMaping)
		{
			fixed (byte* buf = buffer.CurrentBuffer)
			{
				short position = offset == 0 ? (short)0 : *(short*)(buf + offset);
				if (position == -1)
				{
					return null;
				}
				if (referenceMaping.ContainsKey(position))
				{
					return referenceMaping[position] as string;
				}
				int lenght = *(int*)(buf + position);

				fixed (char* charP = new char[lenght])
				{
					int bytesForCopy = sizeof(char) * lenght;
					byte* source = (buf + position + sizeof(int));
					Buffer.MemoryCopy(source, charP, bytesForCopy, bytesForCopy);
					return new String(charP);
				}
			}
		}
		<#}#>
	}
