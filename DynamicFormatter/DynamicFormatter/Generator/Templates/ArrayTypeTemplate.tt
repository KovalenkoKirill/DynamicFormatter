<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="DynamicFormatter.Extentions" #>
<#@ import namespace="DynamicFormatter.Extentions" #>

	public class <#= this.className #> :IResolver<<#=typeInfo.Type.FullName#>>
	{
		public unsafe byte[] Serialize(object Entity, DynamicBuffer buff, Dictionary<object, DynamicBuffer.BufferPtr> referenceMaping)
		{
			int size = <#=sizeof(int)#>;

			if (Entity == null)
			{
				return BitConverter.GetBytes((short)-1);
			}

			if(referenceMaping.ContainsKey(Entity))
			{
				return BitConverter.GetBytes(referenceMaping[Entity].position);
			}

			<#=elementInfo.Type.FullName#>[] array = (<#=elementInfo.Type.FullName#>[])Entity;

			size += <#=elementInfo.SizeInBuffer#> * array.Length;

			var ptr = buff.Alloc(size);

			byte[] buffer = buff.CurrentBuffer;

			referenceMaping.Add(Entity, ptr);
			
			int offset = ptr.position;

			BaseConvertor.Write32(buffer,offset,(byte*)array.Length);

			offset += <#=sizeof(int)#>;

			for(int i = 0;i<array.Length;i++)
			{
				<#=elementInfo.Type.FullName#> value = array[i];


					<#if(this.isPrimitive())
					{#>
						BaseConvertor.Write<#=elementInfo.SizeInBuffer * 8#>(buffer,offset,(byte*)&value);
					<#}
					else if(this.elementInfo.Type == typeof(string))
					{#>
						byte[] result = SerializeString(value,buff,referenceMaping);
						System.Buffer.BlockCopy(result, 0, buffer, offset, result.Length);
					<#}
					else
					{#>
						byte[] result = TypeResolveFactory.ResolveSerialize(<#=this.GetHash(elementInfo.Type)#>,value,buff,referenceMaping);
						System.Buffer.BlockCopy(result, 0, buffer, offset, result.Length);
					<#}#>


				offset += <#=this.elementInfo.SizeInBuffer#>;
			}

			 return BitConverter.GetBytes(ptr.position);
		}

		<#if(this.elementInfo.Type == typeof(string))
		{#>
			public unsafe byte[] SerializeString(object Entity, DynamicBuffer buf, Dictionary<object, DynamicBuffer.BufferPtr> referenceMaping)
		{
			if (Entity == null)
			{
				return BitConverter.GetBytes((short)-1);
			}
			if (referenceMaping.ContainsKey(Entity))
			{
				var bufferPtr = referenceMaping[Entity];
				return BitConverter.GetBytes(bufferPtr.position);
			}
			int charSize = sizeof(char);
			string entity = (string)Entity;
			int size = charSize * entity.Length + sizeof(int);
			var ptr = buf.Alloc(size);
			byte[] buffer = buf.CurrentBuffer;
			int offset = ptr.position;

			int lenght = entity.Length;

			BaseConvertor.Write32(buffer, offset, (byte*)&lenght);

			offset += sizeof(int);

			fixed (char* str = entity)
			fixed(byte* bufferPtr = buffer)
			{
				int bytesToCopy = charSize * entity.Length;
				Buffer.MemoryCopy(str, bufferPtr + offset, bytesToCopy, bytesToCopy);
			}

			return BitConverter.GetBytes(ptr.position);
		}
		<#}#>

		public object instanse(int offset, DynamicBuffer buff, Dictionary<int, object> referenceMaping)
		{
			byte[] buffer = buff.CurrentBuffer;

			short position = (short)offset == 0 ?
				 (short)0 : BaseConvertor.GetShort(buffer, offset);

			if (position == -1)
			{
				return null;
			}
			offset = position;

			int arrayLenght = BaseConvertor.GetInt(buffer, offset);

			<#=elementInfo.Type.FullName#>[] array = new <#=elementInfo.Type.FullName#>[arrayLenght];

			referenceMaping.Add(position, array);

			offset += <#=sizeof(int)#>;

			for(int i = 0;i<arrayLenght;i++)
			{
				<#if(this.isPrimitive())
				{#>
					array[i] = BaseConvertor.Get<#=this.Prefix#>(buffer, offset);
					offset += <#=this.elementInfo.SizeInBuffer#>;
				<#}
				else if(this.elementInfo.Type == typeof(string))
				{#>
					array[i] = DesirializeString(offset,buff,referenceMaping);
					offset += <#=sizeof(ushort)#>;
				<#}
				else
				{#>
					array[i] = (<#=elementInfo.Type.FullName#>)TypeResolveFactory.ResolveDesirialize(typeof(<#=elementInfo.Type.FullName#>),
																		offset,
																		buff,
																		referenceMaping);
					offset += <#=this.elementInfo.SizeInBuffer#>;
				<#}#>
			}
			return array;
		}

		<#if(this.elementInfo.Type == typeof(string))
		{#>
		public unsafe string DesirializeString(int offset, DynamicBuffer buffer, Dictionary<int, object> referenceMaping)
		{
			fixed (byte* buf = buffer.CurrentBuffer)
			{
				short position = offset == 0 ? (short)0 : *(short*)(buf + offset);
				if (position == -1)
				{
					return null;
				}
				if (referenceMaping.ContainsKey(position))
				{
					return referenceMaping[position] as string;
				}
				int lenght = *(int*)(buf + position);

				fixed (char* charP = new char[lenght])
				{
					int bytesForCopy = sizeof(char) * lenght;
					byte* source = (buf + position + sizeof(int));
					Buffer.MemoryCopy(source, charP, bytesForCopy, bytesForCopy);
					return new String(charP);
				}
			}
		}
		<#}#>
	}
